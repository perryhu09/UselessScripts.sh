#!/bin/bash
# malware.sh - Malware Detection Module with AI Analysis
# Dynamic discovery and mitigation of potential backdoors, web shells, and persistence

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/utils.sh"
source "$SCRIPT_DIR/../lib/openrouter.sh"

if [[ -f "$SCRIPT_DIR/readme_parser.sh" ]]; then
    source "$SCRIPT_DIR/readme_parser.sh"
fi

BACKUP_DIR="${BACKUP_DIR:-/var/backups/cyberpatriot}"

# Module: Malware
# Category: Malware
# Description: Detects and mitigates malware, backdoors, and persistence mechanisms

readonly MALWARE_SCAN_DIRS=(
    /tmp
    /var/tmp
    /dev/shm
    /usr/local/bin
    /usr/local/sbin
    /usr/share
    /opt
    /root
)

readonly MALWARE_FILE_PATTERNS=("*.py" "*.pl" "*.sh" "*.php" "*.rb" "*.service")
readonly SUSPICIOUS_CONTENT_REGEX='(/dev/tcp/|bash\s+-i\s+>&\s+/dev/tcp/|nc\s+.*\s+-e|socat\s+.*TCP|wget\s+[^ ]+://|curl\s+[^ ]+://|pty\.spawn|base64\.(b64decode|decode)|chmod\s+\+s|chattr\s+\+i|python3?\s+-c|perl\s+-e|php\s+-r|import\s+paramiko|SimpleHTTPServer|http\.server)'
readonly PERSISTENCE_REGEX='(/tmp|/var/tmp|/dev/shm|nc\s|wget\s|curl\s|python|perl|ruby|php|bash\s+-c|socat|/dev/tcp/|\.py\b|\.pl\b)'

readonly DEFAULT_ALLOWED_LISTENERS=(
    sshd systemd-resolved systemd-networkd NetworkManager dnsmasq avahi-daemon chronyd
    cupsd cups-browsed polkitd dbus-daemon containerd dockerd snapd apache2 nginx lighttpd
    mysql mariadbd postgres vsftpd proftpd pure-ftpd
)

readonly MALWARE_AI_SYSTEM_PROMPT=$(cat <<'EOF'
You are a CyberPatriot malware analyst helping a defensive team.

You will receive JSON describing suspicious files, processes, and persistence artifacts discovered on a Linux host alongside the README critical services list and excerpt. Findings may include process artifacts that contain the executable or script path.

Return ONLY valid JSON in this exact format:
{
  "remove_files": [
    {"path": "/full/path/to/file", "reason": "Brief reason (e.g., Python reverse shell listener)"}
  ],
  "remove_suid": [
    {"path": "/full/path/to/suid/binary", "reason": "Brief reason (e.g., SUID on bash binary)"}
  ],
  "kill_processes": [
    {"pid": "12345", "reason": "Brief reason (e.g., Suspicious netcat listener)"}
  ],
  "investigate_further": ["Items that require manual analyst review"],
  "notes": ["Contextual guidance or follow-up steps"],
  "command_requests": [
    {"command": "cat /path && sha256sum /file", "reason": "Why this command output is needed"}
  ]
}

Request commands when you truly need additional evidence. Consolidate related checks into as few commands as possible, and reuse previously provided outputs instead of repeating requests. After receiving command results, finalize your recommendations without asking for more unless absolutely necessary. Prioritize flagging clear backdoors, reverse shells, and malicious listeners for removal. Flag SUID bits on dangerous binaries like bash, find, python. Flag suspicious processes for termination, and when a malicious process references a script or binary, also include that absolute path in remove_files so the file itself is deleted. Always warn if an action could disrupt README-designated critical services. Provide absolute file paths extracted from the findings artifacts.
EOF
)

# Storage for detected artifacts
declare -a README_CRITICAL_SERVICES=()
declare -a SUSPICIOUS_FINDINGS_JSON=()
declare -a SUSPICIOUS_PROCESSES=()
declare -a SUSPICIOUS_LISTENERS=()
declare -a SUSPICIOUS_FILES=()
declare -a PERSISTENCE_FINDINGS=()
declare -a SUID_FINDINGS=()
declare -a REMEDIATIONS_APPLIED=()

load_readme_context() {
    local data_path="$SCRIPT_DIR/../data/readme_parsed.json"

    if declare -p README_PARSED &>/dev/null && [[ ${README_PARSED:-0} -eq 1 ]]; then
        mapfile -t README_CRITICAL_SERVICES < <(get_critical_services 2>/dev/null | grep -v '^$' || true)
    elif [[ -f "$data_path" ]] && command_exists jq; then
        mapfile -t README_CRITICAL_SERVICES < <(jq -r '.critical_services[]?' "$data_path" 2>/dev/null | grep -v '^$' || true)
    fi

    if [[ ${#README_CRITICAL_SERVICES[@]} -gt 0 ]]; then
        log_info "Loaded ${#README_CRITICAL_SERVICES[@]} critical services from README"
    else
        log_warn "No critical services found in README context"
    fi
}

is_service_marked_critical() {
    local svc="${1,,}"
    for entry in "${README_CRITICAL_SERVICES[@]}"; do
        [[ -z "$entry" ]] && continue
        local normalized="${entry,,}"
        if [[ "$svc" == "$normalized" ]]; then
            return 0
        fi
        case "$svc" in
            ssh|sshd) [[ "$normalized" =~ ssh ]] && return 0 ;;
            apache2|httpd) [[ "$normalized" =~ apache|httpd ]] && return 0 ;;
            nginx) [[ "$normalized" =~ nginx ]] && return 0 ;;
        esac
    done
    return 1
}

record_finding() {
    local type="$1"
    local message="$2"
    local severity="${3:-medium}"
    local artifact="${4:-}"

    case "$type" in
        process) SUSPICIOUS_PROCESSES+=("$message") ;;
        listener) SUSPICIOUS_LISTENERS+=("$message") ;;
        file) SUSPICIOUS_FILES+=("$message") ;;
        persistence) PERSISTENCE_FINDINGS+=("$message") ;;
        suid) SUID_FINDINGS+=("$message") ;;
        remediation) REMEDIATIONS_APPLIED+=("$message") ;;
    esac

    if [[ "$type" == "remediation" ]]; then
        log_success "[REMEDIATION] $message"
    else
        log_warn "[${type^^}][$severity] $message"
    fi

    if command_exists jq; then
        local json
        json=$(jq -n \
            --arg type "$type" \
            --arg message "$message" \
            --arg severity "$severity" \
            --arg artifact "$artifact" \
            '{type:$type, message:$message, severity:$severity, artifact:$artifact}')
        SUSPICIOUS_FINDINGS_JSON+=("$json")
    else
        SUSPICIOUS_FINDINGS_JSON+=("{\"type\":\"$type\",\"message\":\"$message\",\"severity\":\"$severity\",\"artifact\":\"$artifact\"}")
    fi
}

resolve_executable_path() {
    local pid="$1"

    if [[ -L "/proc/$pid/exe" ]]; then
        readlink -f "/proc/$pid/exe" 2>/dev/null || true
    fi
}

extract_command_path() {
    local cmd="$1"
    local token

    for token in $cmd; do
        token="${token%\"}"
        token="${token#\"}"
        token="${token%\'}"
        token="${token#\'}"

        if [[ "$token" == */* ]] && [[ -f "$token" ]]; then
            echo "$token"
            return 0
        fi
    done
}

generate_findings_json() {
    if [[ ${#SUSPICIOUS_FINDINGS_JSON[@]} -eq 0 ]]; then
        echo "[]"
        return 0
    fi

    printf '[\n'
    local i
    for i in "${!SUSPICIOUS_FINDINGS_JSON[@]}"; do
        (( i > 0 )) && printf ',\n'
        printf '%s' "${SUSPICIOUS_FINDINGS_JSON[$i]}"
    done
    printf '\n]\n'
}

call_malware_openrouter() {
    local messages_json="$1"

    if ! check_openrouter_config; then
        return 1
    fi

    local payload
    payload=$(jq -n \
        --arg model "$OPENROUTER_MODEL" \
        --argjson messages "$messages_json" \
        '{model:$model, messages:$messages, temperature:0.1, max_tokens:12000}')

    local response
    response=$(curl -s -X POST "$OPENROUTER_API_URL" \
        -H "Authorization: Bearer $OPENROUTER_API_KEY" \
        -H "Content-Type: application/json" \
        -H "HTTP-Referer: https://github.com/cyberpatriot-linux-auto" \
        -d "$payload")

    local content
    content=$(echo "$response" | jq -r '.choices[0].message.content' 2>/dev/null)

    if [[ -z "$content" || "$content" == "null" ]]; then
        log_error "OpenRouter response did not contain content"
        log_debug "Response: $response"
        return 1
    fi

    echo "$content"
    return 0
}

is_safe_malware_command() {
    local command="$1"
    [[ -n "${command//[[:space:]]/}" ]]
}

extract_malware_command_requests() {
    local response_json="$1"

    echo "$response_json" | jq -c '
        if has("command_requests") then
            if (.command_requests | type == "array") then .command_requests else [] end
        elif has("command_request") then
            if (.command_request | type == "object") then [.command_request] else [] end
        else
            []
        end | map(select(.command and (.command | length > 0)))'
}

execute_malware_command() {
    local command="$1"

    if ! is_safe_malware_command "$command"; then
        log_warn "Rejected empty command request: $command"
        jq -n \
            --arg command "$command" \
            '{command: $command, exit_code: 126, stdout: "", stderr: "Command rejected by policy"}'
        return 0
    fi

    local stdout_file stderr_file
    stdout_file=$(mktemp)
    stderr_file=$(mktemp)

    bash -c "$command" >"$stdout_file" 2>"$stderr_file"
    local exit_code=$?
    local stdout
    local stderr
    stdout=$(cat "$stdout_file")
    stderr=$(cat "$stderr_file")
    rm -f "$stdout_file" "$stderr_file"

    jq -n \
        --arg command "$command" \
        --arg stdout "$stdout" \
        --arg stderr "$stderr" \
        --argjson exit_code "$exit_code" \
        '{command: $command, exit_code: $exit_code, stdout: $stdout, stderr: $stderr}'
}

quarantine_file() {
    local file="$1"
    local reason="$2"

    if [[ ! -f "$file" ]]; then
        return 0
    fi

    mkdir -p "$BACKUP_DIR/quarantine"
    local base=$(basename "$file")
    local ts=$(date +%Y%m%d_%H%M%S)
    local dest="$BACKUP_DIR/quarantine/${base}.${ts}.quarantined"

    if mv "$file" "$dest" 2>/dev/null; then
        record_finding "remediation" "Quarantined $file (reason: $reason)" "high" "$dest"
    else
        log_warn "Failed to quarantine $file"
    fi
}

check_optional_security_tooling() {
    if command_exists clamscan; then
        log_info "ClamAV (clamscan) is installed"
    else
        log_warn "ClamAV not installed (install with: sudo apt-get install clamav)"
    fi

    if command_exists rkhunter; then
        log_info "rkhunter is installed"
    else
        log_warn "rkhunter not installed (install with: sudo apt-get install rkhunter)"
    fi
}

run_rootkit_scans() {
    log_section "Running Rootkit Scans"

    local RK_LOG="/var/log/rkhunter.log"
    local CRK_LOG="/var/log/chkrootkit.log"

    # Install or reinstall rkhunter
    if ! dpkg -s rkhunter &>/dev/null; then
        log_info "Installing rkhunter..."
        DEBIAN_FRONTEND=noninteractive apt-get install -y -qq rkhunter &>/dev/null
        log_success "rkhunter installed successfully"
    else
        log_info "rkhunter already installed"
    fi

    # Install or reinstall chkrootkit
    if ! dpkg -s chkrootkit &>/dev/null; then
        log_info "Installing chkrootkit..."
        DEBIAN_FRONTEND=noninteractive apt-get install -y -qq chkrootkit &>/dev/null
        log_success "chkrootkit installed successfully"
    else
        log_info "chkrootkit already installed"
    fi

    # Configure rkhunter
    if [[ -f /etc/rkhunter.conf ]]; then
        backup_file /etc/rkhunter.conf
        log_info "Configuring rkhunter..."
        sed -i 's/^[#[:space:]]*UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' /etc/rkhunter.conf 2>/dev/null || true
        sed -i 's/^[#[:space:]]*MIRRORS_MODE=.*/MIRRORS_MODE=1/' /etc/rkhunter.conf 2>/dev/null || true
        sed -i 's|^[#[:space:]]*WEB_CMD=.*|WEB_CMD="wget -q"|' /etc/rkhunter.conf 2>/dev/null || true
    fi

    # Update rkhunter database
    log_info "Updating rkhunter signatures database..."
    rkhunter --update &>>"$RK_LOG" || true

    # Build baseline file property database
    log_info "Building rkhunter file property baseline..."
    rkhunter --propupd &>>"$RK_LOG" || true

    # Run rkhunter scan
    log_info "Starting rkhunter system scan (this may take several minutes)..."
    rkhunter --check --sk --nocolors --noappend-log &>>"$RK_LOG" || true
    log_success "rkhunter scan completed. Full log: $RK_LOG"

    # Run chkrootkit scan
    log_info "Starting chkrootkit system scan..."
    chkrootkit -q >"$CRK_LOG" 2>&1 || true
    log_success "chkrootkit scan completed. Full log: $CRK_LOG"

    # Basic alerting based on common warning patterns
    log_info "Analyzing scan results for suspicious findings..."
    local RK_ALERTS CRK_ALERTS
    RK_ALERTS=$(grep -Ei "Warning|suspect|infected|rootkit" "$RK_LOG" 2>/dev/null | wc -l)
    CRK_ALERTS=$(grep -Ei "INFECTED|Vulnerable|Warning" "$CRK_LOG" 2>/dev/null | wc -l)

    if [[ "${RK_ALERTS:-0}" -gt 0 ]] || [[ "${CRK_ALERTS:-0}" -gt 0 ]]; then
        log_warn "ALERT: Potential security issues detected by rootkit scanners"
        log_warn "ALERT: rkhunter warnings: ${RK_ALERTS}, chkrootkit warnings: ${CRK_ALERTS}"
        log_warn "ALERT: Review full logs at $RK_LOG and $CRK_LOG"
    else
        log_success "No obvious rootkit indicators found in scans"
    fi
}

scan_suspicious_processes() {
    log_section "Process Analysis"
    local regex='(/dev/tcp/|bash[[:space:]]+-i[[:space:]]+>&[[:space:]]+/dev/tcp/|nc[[:space:]].*(-e|-c)|socat[[:space:]].*TCP|python[0-9.]*[[:space:]].*-c[[:space:]].*(socket|base64)|perl[[:space:]].*-e[[:space:]].*(socket|system)|php[[:space:]].*-r[[:space:]].*(system|shell_exec)|openssl[[:space:]].*-connect[[:space:]].*sh)'

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        line="${line## }"
        local pid user cmd
        pid=${line%% *}
        local remaining="${line#* }"
        remaining="${remaining## }"
        user=${remaining%% *}
        cmd=${remaining#* }
        cmd="${cmd## }"

        if [[ "$cmd" =~ $regex ]] || [[ "$cmd" == */tmp/* ]] || [[ "$cmd" == */var/tmp/* ]]; then
            local exe_path
            exe_path=$(resolve_executable_path "$pid")

            local script_path
            script_path=$(extract_command_path "$cmd")

            local description="PID $pid ($user) running suspicious command: $cmd"
            if [[ -n "$exe_path" ]]; then
                description+=" [exe: $exe_path]"
            fi
            if [[ -n "$script_path" && "$script_path" != "$exe_path" ]]; then
                description+=" [script: $script_path]"
            fi

            local artifact="${script_path:-${exe_path:-$pid}}"
            record_finding "process" "$description" "high" "$artifact"
        fi
    done < <(ps axww -o pid=,user=,command=)
}

scan_network_listeners() {
    log_section "Network Listener Analysis"

    if ! command_exists ss; then
        log_warn "ss command not available; skipping listener analysis"
        return
    fi

    local allowlist=("${DEFAULT_ALLOWED_LISTENERS[@]}")
    if [[ ${#README_CRITICAL_SERVICES[@]} -gt 0 ]]; then
        allowlist+=("${README_CRITICAL_SERVICES[@]}")
    fi

    local listener_output
    listener_output=$(ss -tulpen 2>/dev/null)
    if [[ -z "$listener_output" ]]; then
        log_info "No listening sockets detected"
        return
    fi

    log_debug "Active listeners:\n$listener_output"

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        [[ "$line" == State* ]] && continue

        local pid
        pid=$(echo "$line" | sed -n 's/.*pid=\([0-9]\+\).*/\1/p')
        local comm=""
        if [[ -n "$pid" && -r "/proc/$pid/comm" ]]; then
            comm=$(tr -d '\0' <"/proc/$pid/comm" 2>/dev/null)
        fi

        local allowed=0
        local candidate="${comm,,}"
        for item in "${allowlist[@]}"; do
            [[ -z "$item" ]] && continue
            if [[ "$candidate" == "${item,,}" ]]; then
                allowed=1
                break
            fi
        done

        if [[ $allowed -eq 0 ]]; then
            local exe_path
            exe_path=$(resolve_executable_path "$pid")

            local script_path
            script_path=$(extract_command_path "$line")

            local description="Suspicious listener: $line"
            if [[ -n "$exe_path" ]]; then
                description+=" [exe: $exe_path]"
            fi
            if [[ -n "$script_path" && "$script_path" != "$exe_path" ]]; then
                description+=" [script: $script_path]"
            fi

            local artifact="${script_path:-${exe_path:-$pid}}"
            record_finding "listener" "$description" "medium" "$artifact"
        fi
    done <<< "$listener_output"
}

sanitize_cron_file() {
    local file="$1"
    local matches="$2"

    if [[ -z "$matches" ]]; then
        return 0
    fi

    if ! command_exists python3; then
        log_warn "python3 unavailable; cannot automatically sanitize $file"
        return 1
    fi

    backup_file "$file"
    local pattern="$PERSISTENCE_REGEX"
    local result
    result=$(python3 - "$file" "$pattern" <<'PY'
import re
import sys
from pathlib import Path

path = Path(sys.argv[1])
pattern = re.compile(sys.argv[2], re.IGNORECASE)
changed = False
lines = path.read_text().splitlines()
output = []
for line in lines:
    if pattern.search(line) and not line.lstrip().startswith('# DISABLED BY CYBERPATRIOT:'):
        output.append('# DISABLED BY CYBERPATRIOT: ' + line)
        changed = True
    else:
        output.append(line)
path.write_text('\n'.join(output) + '\n')
if changed:
    print('changed')
PY
)

    if [[ "$result" == "changed" ]]; then
        record_finding "remediation" "Commented suspicious cron entries in $file" "high" "$file"
    else
        log_info "No changes applied to $file"
    fi
}

scan_persistence_mechanisms() {
    log_section "Persistence Analysis"
    local cron_files=(/etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.weekly/* /var/spool/cron/crontabs/*)

    for cron in "${cron_files[@]}"; do
        [[ -f "$cron" ]] || continue
        local hits
        hits=$(grep -En "$PERSISTENCE_REGEX" "$cron" 2>/dev/null || true)
        if [[ -n "$hits" ]]; then
            local preview
            preview=$(echo "$hits" | head -n 3 | tr '\n' ';' | sed 's/;*$//')
            record_finding "persistence" "Suspicious cron entries detected in $cron (matches: $preview)" "high" "$cron"
            sanitize_cron_file "$cron" "$hits"
        fi
    done

    scan_ld_preload
    scan_suspicious_skel

    local unit_dirs=(/etc/systemd/system /lib/systemd/system)
    local dir
    for dir in "${unit_dirs[@]}"; do
        [[ -d "$dir" ]] || continue
        while IFS= read -r -d '' unit; do
            local exec_line
            exec_line=$(grep -E '^ExecStart=' "$unit" 2>/dev/null | grep -Ei "$PERSISTENCE_REGEX" || true)
            [[ -z "$exec_line" ]] && continue

            local service_name=$(basename "$unit")
            service_name="${service_name%.service}"

            if ! is_service_marked_critical "$service_name"; then
                record_finding "persistence" "Disabling suspicious systemd unit $service_name ($unit)" "high" "$unit"
                systemctl disable --now "$service_name" 2>/dev/null || true
                mv "$unit" "$unit.disabled" 2>/dev/null || true
                record_finding "remediation" "Masked suspicious systemd service $service_name" "high" "$unit.disabled"
            else
                record_finding "persistence" "Suspicious ExecStart in critical service $service_name (manual review)" "medium" "$unit"
            fi
        done < <(find "$dir" -maxdepth 1 -name '*.service' -print0 2>/dev/null)
    done
}

scan_webshells() {
    log_section "Webshell Detection"
    local -a web_roots=(/var/www /srv/www /var/lib/www /usr/share/nginx /usr/local/www)
    local scanned_root=0
    local found_webshell=0

    for root in "${web_roots[@]}"; do
        [[ -d "$root" ]] || continue
        scanned_root=1
        while IFS= read -r -d '' file; do
            local hit
            hit=$(grep -E "(system\\(|shell_exec|passthru|eval|assert\\(|base64_decode|pfsockopen|proc_open|allow_url_include|preg_replace\\s*\(/e)" "$file" 2>/dev/null || true)
            if [[ -n "$hit" ]]; then
                record_finding "file" "Potential web shell: $file" "high" "$file"
                found_webshell=1
            fi
        done < <(find "$root" -type f \( -name '*.php' -o -name '*.jsp' -o -name '*.asp' -o -name '*.aspx' -o -name '*.pl' \) -size -1M -print0 2>/dev/null)
    done

    if (( scanned_root == 0 )); then
        log_info "No common web roots present; skipping webshell scan"
    elif (( found_webshell == 0 )); then
        log_info "No obvious web shells detected in discovered web roots"
    fi
}

scan_ld_preload() {
    local preload_file="/etc/ld.so.preload"

    if [[ ! -e "$preload_file" ]]; then
        log_info "No $preload_file present"
        return
    fi

    if [[ -L "$preload_file" ]]; then
        local target
        target=$(readlink -f "$preload_file" 2>/dev/null || echo "unknown")
        record_finding "persistence" "$preload_file is a symlink to $target" "medium" "$preload_file"
    fi

    local entries=()
    while IFS= read -r line; do
        line="${line%%#*}"
        line="${line//[[:space:]]/}"
        [[ -z "$line" ]] && continue
        entries+=("$line")
    done <"$preload_file"

    if (( ${#entries[@]} == 0 )); then
        record_finding "persistence" "$preload_file exists but contains no active entries" "low" "$preload_file"
        return
    fi

    local disable_reason=""
    local entry
    for entry in "${entries[@]}"; do
        if [[ "$entry" =~ /tmp|/var/tmp|/dev/shm|/home|/etc/skel ]]; then
            disable_reason="untrusted path $entry"
            break
        fi
        if [[ ! -f "$entry" ]]; then
            disable_reason="missing library $entry referenced in ld.so.preload"
            break
        fi
    done

    if [[ -n "$disable_reason" ]]; then
        backup_file "$preload_file"
        mv "$preload_file" "$preload_file.cyberpatriot-disabled" 2>/dev/null || true
        record_finding "remediation" "Disabled $preload_file due to $disable_reason" "high" "$preload_file"
    else
        record_finding "persistence" "$preload_file present with entries: ${entries[*]}" "medium" "$preload_file"
    fi
}

scan_suspicious_skel() {
    local skel_dir="/etc/skel"
    [[ -d "$skel_dir" ]] || return

    local flagged=0
    while IFS= read -r -d '' file; do
        local hit
        hit=$(grep -E "$SUSPICIOUS_CONTENT_REGEX" "$file" 2>/dev/null || true)
        if [[ -n "$hit" ]]; then
            record_finding "persistence" "Suspicious default profile content in $file" "medium" "$file"
            flagged=1
        fi
    done < <(find "$skel_dir" -type f \( -name '*profile*' -o -name '*.sh' -o -name '*.bash*' -o -name '*.zsh*' -o -executable \) -size -512k -print0 2>/dev/null)

    if (( flagged == 0 )); then
        log_info "No suspicious defaults detected in $skel_dir"
    fi
}

collect_candidate_files() {
    local -n __out=$1
    __out=()

    local dir
    for dir in "${MALWARE_SCAN_DIRS[@]}"; do
        [[ -d "$dir" ]] || continue
        while IFS= read -r -d '' file; do
            # Filter by pattern or SUID bit
            local include=0
            local name=$(basename "$file")
            for pattern in "${MALWARE_FILE_PATTERNS[@]}"; do
                if [[ $name == $pattern ]]; then
                    include=1
                    break
                fi
            done
            if [[ $include -eq 0 ]]; then
                if [[ -u "$file" ]]; then
                    include=1
                fi
            fi
            if [[ $include -eq 1 ]]; then
                __out+=("$file")
            fi
        done < <(find "$dir" -xdev -type f -size -1M -print0 2>/dev/null)
    done
}

run_heuristic_scanner() {
    local -n __files=$1
    (( ${#__files[@]} )) || return 0

    if ! command_exists python3; then
        log_warn "python3 not available; skipping heuristic scan"
        return 1
    fi

    local helper
    helper=$(mktemp)
    cat <<'PY' >"$helper"
#!/usr/bin/env python3
import json
import pathlib
import re
import sys

SUSPICIOUS_PATTERNS = [
    r"/dev/tcp/",
    r"bash\s+-i\s+>&\s+/dev/tcp/",
    r"nc\s+.*\s+-e",
    r"socket\.socket",
    r"pty\.spawn",
    r"subprocess\.(Popen|call|run)",
    r"base64\.b64decode",
    r"exec\(",
    r"eval\(",
    r"SimpleHTTPServer",
    r"http\.server",
    r"wget\s+[a-z]+://",
    r"curl\s+[a-z]+://",
    r"chmod\s+\+s",
    r"chattr\s+\+i",
]

CATEGORY_PATTERNS = {
    "reverse_shell": [r"/dev/tcp/", r"bash\s+-i\s+>&\s+/dev/tcp/", r"nc\s+.*\s+-e"],
    "network": [r"socket\.socket", r"SimpleHTTPServer", r"http\.server", r"wget\s", r"curl\s"],
    "persistence": [r"chmod\s+\+s", r"chattr\s+\+i"],
    "evasion": [r"base64\.b64decode", r"exec\(", r"eval\("]
}

WEIGHTS = {
    "reverse_shell": 40,
    "network": 25,
    "persistence": 20,
    "evasion": 15,
}

results = []
for item in sys.argv[1:]:
    path = pathlib.Path(item)
    try:
        if not path.is_file():
            continue
        if path.stat().st_size > 1_000_000:
            continue
        data = path.read_text(errors='ignore')
    except Exception:
        continue

    score = 0
    tags = []
    for category, patterns in CATEGORY_PATTERNS.items():
        for pattern in patterns:
            if re.search(pattern, data, re.IGNORECASE):
                if category not in tags:
                    tags.append(category)
                    score += WEIGHTS.get(category, 10)
                break
    hits = sum(1 for pattern in SUSPICIOUS_PATTERNS if re.search(pattern, data, re.IGNORECASE))
    score += min(hits * 5, 40)
    if score >= 30:
        results.append({"file": str(path), "score": min(score, 100), "tags": tags})

print(json.dumps(results))
PY
    chmod +x "$helper"

    local json
    json=$(python3 "$helper" "${__files[@]}" 2>/dev/null)
    rm -f "$helper"

    if [[ -z "$json" ]]; then
        return 0
    fi

    if command_exists jq; then
        local count
        count=$(echo "$json" | jq 'length' 2>/dev/null)
        if [[ "$count" -gt 0 ]]; then
            log_info "Heuristic scanner flagged $count files"
            echo "$json" | jq -c '.[]' | while read -r entry; do
                local path score tags
                path=$(echo "$entry" | jq -r '.file')
                score=$(echo "$entry" | jq -r '.score')
                tags=$(echo "$entry" | jq -r '.tags | join(",")')
                record_finding "file" "Suspicious script $path (score: $score, tags: $tags)" "high" "$path"
                if (( score >= 80 )) && [[ "$path" == /tmp/* || "$path" == /var/tmp/* || "$path" == /dev/shm/* ]]; then
                    quarantine_file "$path" "High heuristic score $score"
                fi
            done
        fi
    fi
}

scan_service_specific_artifacts() {
    log_section "Service-Aware Malware Scan"

    if printf '%s\n' "${README_CRITICAL_SERVICES[@]}" | grep -qi 'ssh'; then
        while IFS= read -r -d '' file; do
            local hit
            hit=$(grep -E "(paramiko|pty\.spawn|/dev/tcp/|socket\.socket)" "$file" 2>/dev/null || true)
            if [[ -n "$hit" ]]; then
                record_finding "file" "SSH-adjacent suspicious script: $file" "medium" "$file"
            fi
        done < <(find /usr/share /usr/lib -maxdepth 4 -type f -name '*.py' -print0 2>/dev/null)
    fi
}

scan_filesystem() {
    log_section "Filesystem Scan"
    local -a candidates=()
    collect_candidate_files candidates

    if (( ${#candidates[@]} == 0 )); then
        log_info "No candidate files discovered for malware sweep"
        return
    fi

    local chunk_size=200
    local idx=0
    while (( idx < ${#candidates[@]} )); do
        local slice=("${candidates[@]:idx:chunk_size}")
        if command_exists grep; then
            local hits
            hits=$(grep -El "$SUSPICIOUS_CONTENT_REGEX" "${slice[@]}" 2>/dev/null || true)
            if [[ -n "$hits" ]]; then
                while IFS= read -r path; do
                    [[ -z "$path" ]] && continue
                    record_finding "file" "Signature match for suspicious content: $path" "high" "$path"
                done <<< "$hits"
            fi
        fi
        (( idx += chunk_size ))
    done

    run_heuristic_scanner candidates
}

prompt_user_approval() {
    local item_type="$1"
    local item_path="$2"
    local reason="$3"

    echo ""
    echo "--------------------------------------------------------------------"
    echo -e "\033[1;31m+-------------------------------------------------------------+\033[0m"
    echo -e "\033[1;31m| MALWARE REMOVAL REQUEST                                     |\033[0m"
    echo -e "\033[1;31m+-------------------------------------------------------------+\033[0m"
    echo -e "\033[1;33mType:\033[0m $item_type"
    echo -e "\033[1;33mPath/ID:\033[0m $item_path"
    echo -e "\033[1;33mReason:\033[0m $reason"
    echo "--------------------------------------------------------------------"
    echo ""
    echo -n -e "\033[1;31mRemove this $item_type? [y/N]:\033[0m "

    local response=""
    local read_status=1

    if [[ -t 0 ]]; then
        if read -r -t 60 response; then
            read_status=0
        fi
    elif [[ -r /dev/tty ]]; then
        if read -r -t 60 response < /dev/tty; then
            read_status=0
        fi
    fi

    if (( read_status != 0 )); then
        echo ""
        log_warn "No response received (timeout or non-interactive), skipping..."
        return 1
    fi

    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')

    if [[ "$response" == "y" || "$response" == "yes" ]]; then
        return 0
    else
        log_info "Skipped removal of $item_path"
        return 1
    fi
}

kill_process_safely() {
    local pid="$1"
    local reason="$2"

    if ! prompt_user_approval "process" "PID $pid" "$reason"; then
        return 1
    fi

    if [[ ! -d "/proc/$pid" ]]; then
        log_warn "Process $pid no longer exists"
        return 1
    fi

    local comm=""
    if [[ -r "/proc/$pid/comm" ]]; then
        comm=$(cat "/proc/$pid/comm" 2>/dev/null || echo "unknown")
    fi

    log_info "Killing process $pid ($comm)..."

    # Try SIGTERM first
    if kill -15 "$pid" 2>/dev/null; then
        sleep 1
        if [[ ! -d "/proc/$pid" ]]; then
            record_finding "remediation" "Terminated process $pid ($comm) - $reason" "high" "$pid"
            return 0
        fi
    fi

    # Force kill if still running
    if kill -9 "$pid" 2>/dev/null; then
        sleep 0.5
        if [[ ! -d "/proc/$pid" ]]; then
            record_finding "remediation" "Force-killed process $pid ($comm) - $reason" "high" "$pid"
            return 0
        fi
    fi

    log_error "Failed to kill process $pid"
    return 1
}

remove_suid_bit() {
    local file="$1"
    local reason="$2"

    if [[ ! -f "$file" ]]; then
        log_warn "File not found: $file"
        return 1
    fi

    if ! prompt_user_approval "SUID bit" "$file" "$reason"; then
        return 1
    fi

    log_info "Removing SUID bit from $file..."

    if chmod u-s "$file" 2>/dev/null; then
        record_finding "remediation" "Removed SUID bit from $file - $reason" "high" "$file"
        return 0
    else
        log_error "Failed to remove SUID bit from $file"
        return 1
    fi
}

remove_file_safely() {
    local file="$1"
    local reason="$2"

    if [[ ! -e "$file" ]]; then
        log_warn "File not found: $file"
        return 1
    fi

    if ! prompt_user_approval "file" "$file" "$reason"; then
        return 1
    fi

    log_info "Removing file $file..."

    # Check for processes using this file
    if command_exists lsof; then
        local pids
        pids=$(lsof -t "$file" 2>/dev/null || true)
        if [[ -n "$pids" ]]; then
            log_warn "Processes using $file: $pids"
            for pid in $pids; do
                local comm=""
                if [[ -r "/proc/$pid/comm" ]]; then
                    comm=$(cat "/proc/$pid/comm" 2>/dev/null || echo "unknown")
                fi
                log_warn "  PID $pid ($comm)"
                echo -n -e "\033[1;33mKill process $pid ($comm) to release file? [y/N]:\033[0m "
                local response
                if read -t 30 response; then
                    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
                    if [[ "$response" == "y" || "$response" == "yes" ]]; then
                        log_info "Killing process $pid..."
                        kill -9 "$pid" 2>/dev/null || true
                        sleep 0.5
                    fi
                else
                    echo ""
                    log_info "Skipping process $pid (timeout)"
                fi
            done
        fi
    fi

    # Remove immutable flag if present
    if command_exists lsattr && lsattr "$file" 2>/dev/null | grep -q '\-i\-'; then
        log_info "Removing immutable flag from $file..."
        if ! chattr -i "$file" 2>/dev/null; then
            log_warn "Failed to remove immutable flag, trying anyway..."
        fi
    fi

    # Backup before removal
    backup_file "$file" 2>/dev/null || true

    # Remove the file
    if rm -f "$file" 2>/dev/null; then
        record_finding "remediation" "Removed malicious file $file - $reason" "high" "$file"
        return 0
    else
        log_error "Failed to remove $file"
        return 1
    fi
}

scan_suid_anomalies() {
    log_section "SUID Audit"
    while IFS= read -r -d '' file; do
        local base=$(basename "$file")
        case "$file" in
            /usr/bin/sudo|/usr/bin/passwd|/usr/bin/chsh|/usr/bin/chfn|/usr/bin/gpasswd|/usr/bin/newgrp|/usr/lib/openssh/ssh-keysign|/usr/lib/dbus-1.0/dbus-daemon-launch-helper)
                continue
                ;;
        esac

        record_finding "suid" "Unexpected SUID binary: $file" "medium" "$file"
        if [[ "$base" == "find" || "$base" == "bash" || "$base" == "sh" ]]; then
            chmod u-s "$file" 2>/dev/null || true
            record_finding "remediation" "Removed SUID bit from $file" "high" "$file"
        fi
    done < <(find / -xdev -perm -4000 -type f -print0 2>/dev/null)
}

analyze_findings_with_ai() {
    if [[ ${#SUSPICIOUS_FINDINGS_JSON[@]} -eq 0 ]]; then
        return 0
    fi

    if ! command_exists jq; then
        log_warn "jq not available; skipping AI malware triage"
        return 1
    fi

    if ! check_openrouter_config; then
        log_info "OpenRouter API key not configured; skipping AI malware triage"
        return 1
    fi

    local findings_json
    findings_json=$(generate_findings_json)

    local critical_joined="None specified"
    if [[ ${#README_CRITICAL_SERVICES[@]} -gt 0 ]]; then
        critical_joined=$(printf '%s,' "${README_CRITICAL_SERVICES[@]}")
        critical_joined=${critical_joined%,}
    fi

    local readme_excerpt=""
    local readme_plain="$SCRIPT_DIR/../data/readme_plaintext.txt"
    if [[ -f "$readme_plain" ]]; then
        readme_excerpt=$(head -n 200 "$readme_plain")
    fi

    local user_message
    user_message=$(cat <<EOF2
Malware findings JSON:
$findings_json

Critical services from README: $critical_joined

README excerpt (first 200 lines):
$readme_excerpt
EOF2
)

    local messages
    messages=$(jq -n \
        --arg system "$MALWARE_AI_SYSTEM_PROMPT" \
        --arg user "$user_message" \
        '[{"role": "system", "content": $system}, {"role": "user", "content": $user}]')

    local round=1
    local max_rounds=3
    local parsed_json=""
    local last_ai_content=""

    mkdir -p "$SCRIPT_DIR/../data"

    while (( round <= max_rounds )); do
        local ai_content
        ai_content=$(call_malware_openrouter "$messages") || return 1
        last_ai_content="$ai_content"

        echo "$ai_content" >"$SCRIPT_DIR/../data/malware_ai_round${round}.txt"

        local extracted_json
        extracted_json=$(extract_json_from_response "$ai_content" 2>/dev/null || true)

        local command_requests="[]"
        if [[ -n "$extracted_json" ]] && echo "$extracted_json" | jq -e '.' >/dev/null 2>&1; then
            command_requests=$(extract_malware_command_requests "$extracted_json")
        else
            extracted_json=""
        fi

        if [[ "$command_requests" == "[]" || $round -eq $max_rounds ]]; then
            parsed_json="$extracted_json"
            break
        fi

        local command_results=()
        local index=0

        while IFS= read -r command_obj; do
            local command
            command=$(echo "$command_obj" | jq -r '.command')
            local reason
            reason=$(echo "$command_obj" | jq -r '.reason // ""')
            index=$((index + 1))

            log_info "AI requested command ($index): $command"
            [[ -n "$reason" ]] && log_info "Reason: $reason"

            local command_result
            command_result=$(execute_malware_command "$command")
            command_results+=("$command_result")

            local exit_code
            exit_code=$(echo "$command_result" | jq -r '.exit_code')
            log_info "Command exit code: $exit_code"
        done < <(echo "$command_requests" | jq -c '.[]')

        local command_results_json
        command_results_json=$(printf '%s\n' "${command_results[@]}" | jq -s '.')
        echo "$command_results_json" | jq '.' >"$SCRIPT_DIR/../data/malware_ai_command_result_round${round}.json"

        local followup_user
        followup_user=$(jq -n \
            --argjson command_results "$command_results_json" \
            --arg findings "$findings_json" \
            --arg summary "Use these command outputs and previous findings to finalize malware remediation. If one more consolidated command is necessary, request it; otherwise provide the final JSON now." \
            '{task: "Provide final malware remediation using command outputs.", findings: $findings, command_results: $command_results, guidance: $summary}' | jq -c '.')

        messages=$(echo "$messages" | jq \
            --arg assistant "$ai_content" \
            --arg user "$followup_user" \
            '. + [ {"role": "assistant", "content": $assistant}, {"role": "user", "content": $user} ]')

        round=$((round + 1))
    done

    log_section "AI Malware Triage"

    if [[ -n "$parsed_json" ]] && echo "$parsed_json" | jq -e '.' >/dev/null 2>&1; then
        log_info "AI recommendations (parsed JSON):"
        echo "$parsed_json" | jq '.'
        echo "$parsed_json" | jq '.' >"$SCRIPT_DIR/../data/malware_ai_recommendations.json"

        # Process AI recommendations for automated remediation
        log_section "AI-Recommended Remediation"

        # Display notes first
        local notes_count
        notes_count=$(echo "$parsed_json" | jq -r '.notes // [] | length' 2>/dev/null)
        if [[ "$notes_count" -gt 0 ]]; then
            log_info "=== NOTES ==="
            echo "$parsed_json" | jq -r '.notes[]?' 2>/dev/null | while read -r note; do
                [[ -z "$note" ]] && continue
                log_info "  - $note"
            done
            echo ""
        fi

        # Display items to investigate manually
        local investigate_count
        investigate_count=$(echo "$parsed_json" | jq -r '.investigate_further // [] | length' 2>/dev/null)
        if [[ "$investigate_count" -gt 0 ]]; then
            log_warn "=== REQUIRES MANUAL REVIEW ==="
            echo "$parsed_json" | jq -r '.investigate_further[]?' 2>/dev/null | while read -r item; do
                [[ -z "$item" ]] && continue
                log_warn "  - $item"
            done
            echo ""
        fi

        # Process file removals
        local remove_files_count
        remove_files_count=$(echo "$parsed_json" | jq -r '.remove_files // [] | length' 2>/dev/null)
        if [[ "$remove_files_count" -gt 0 ]]; then
            log_info "=== FILES FLAGGED FOR REMOVAL ==="
            echo "$parsed_json" | jq -c '.remove_files[]?' 2>/dev/null | while read -r entry; do
                local file_path reason
                file_path=$(echo "$entry" | jq -r '.path' 2>/dev/null)
                reason=$(echo "$entry" | jq -r '.reason' 2>/dev/null)

                if [[ -n "$file_path" && "$file_path" != "null" ]]; then
                    remove_file_safely "$file_path" "$reason" || true
                fi
            done
            echo ""
        fi

        # Process SUID removals
        local remove_suid_count
        remove_suid_count=$(echo "$parsed_json" | jq -r '.remove_suid // [] | length' 2>/dev/null)
        if [[ "$remove_suid_count" -gt 0 ]]; then
            log_info "=== SUID BITS FLAGGED FOR REMOVAL ==="
            echo "$parsed_json" | jq -c '.remove_suid[]?' 2>/dev/null | while read -r entry; do
                local file_path reason
                file_path=$(echo "$entry" | jq -r '.path' 2>/dev/null)
                reason=$(echo "$entry" | jq -r '.reason' 2>/dev/null)

                if [[ -n "$file_path" && "$file_path" != "null" ]]; then
                    remove_suid_bit "$file_path" "$reason" || true
                fi
            done
            echo ""
        fi

        # Process process kills
        local kill_processes_count
        kill_processes_count=$(echo "$parsed_json" | jq -r '.kill_processes // [] | length' 2>/dev/null)
        if [[ "$kill_processes_count" -gt 0 ]]; then
            log_info "=== PROCESSES FLAGGED FOR TERMINATION ==="
            echo "$parsed_json" | jq -c '.kill_processes[]?' 2>/dev/null | while read -r entry; do
                local pid reason
                pid=$(echo "$entry" | jq -r '.pid' 2>/dev/null)
                reason=$(echo "$entry" | jq -r '.reason' 2>/dev/null)

                if [[ -n "$pid" && "$pid" != "null" ]]; then
                    kill_process_safely "$pid" "$reason" || true
                fi
            done
            echo ""
        fi
    else
        log_info "AI recommendations: $last_ai_content"
        printf '%s\n' "$last_ai_content" >"$SCRIPT_DIR/../data/malware_ai_recommendations.json"
    fi
}

summarize_findings() {
    log_section "Malware Findings Summary"

    log_info "Suspicious processes detected: ${#SUSPICIOUS_PROCESSES[@]}"
    if [[ ${#SUSPICIOUS_PROCESSES[@]} -gt 0 ]]; then
        for entry in "${SUSPICIOUS_PROCESSES[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Suspicious listeners detected: ${#SUSPICIOUS_LISTENERS[@]}"
    if [[ ${#SUSPICIOUS_LISTENERS[@]} -gt 0 ]]; then
        for entry in "${SUSPICIOUS_LISTENERS[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Suspicious files detected: ${#SUSPICIOUS_FILES[@]}"
    if [[ ${#SUSPICIOUS_FILES[@]} -gt 0 ]]; then
        for entry in "${SUSPICIOUS_FILES[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Persistence findings: ${#PERSISTENCE_FINDINGS[@]}"
    if [[ ${#PERSISTENCE_FINDINGS[@]} -gt 0 ]]; then
        for entry in "${PERSISTENCE_FINDINGS[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "SUID anomalies: ${#SUID_FINDINGS[@]}"
    if [[ ${#SUID_FINDINGS[@]} -gt 0 ]]; then
        for entry in "${SUID_FINDINGS[@]}"; do
            log_warn "  - $entry"
        done
    fi

    log_info "Remediations applied: ${#REMEDIATIONS_APPLIED[@]}"
    if [[ ${#REMEDIATIONS_APPLIED[@]} -gt 0 ]]; then
        for entry in "${REMEDIATIONS_APPLIED[@]}"; do
            log_success "  - $entry"
        done
    fi
}

run_malware() {
    log_section "Starting Malware Detection Module"

    require_root
    load_readme_context
    check_optional_security_tooling

    # Run rootkit scans first
    run_rootkit_scans

    # Dynamic malware detection
    scan_suspicious_processes
    scan_network_listeners
    scan_persistence_mechanisms
    scan_webshells
    scan_service_specific_artifacts
    scan_filesystem
    scan_suid_anomalies

    # Summarize and AI analysis
    summarize_findings
    analyze_findings_with_ai

    log_success "Malware Detection module completed"
    return 0
}

export -f run_malware
